\chapter{Cryptocurrency Mining}
%
\section{Overview}
%
\section{\label{sec:Bitcoin}Bitcoin}
%\setlength{\intextsep}{0pt}
\begin{wrapfigure}{L}{0.3\textwidth}
\centering
\includegraphics[width=0.20\textwidth]{Images/Bitcoin/index.jpeg}
\end{wrapfigure}
Bitcoin~\cite{Nakamoto_bitcoin:a} is a decentralized digital currency that enables instant payments to anyone, anywhere in the world. Bitcoin uses peer-to-peer technology to operate with no central authority: transaction management and money issuance are carried out collectively by the network.

The original Bitcoin software by Satoshi Nakamoto was released under the MIT license. Most client software, derived or "from scratch", also use open source licensing.

Bitcoin is the first successful implementation of a distributed cryptocurrency, described in part in 1998 by Wei Dai on the cypherpunks mailing list. For the reader to understand what this list was, we reproduce from \emph{cryptoanarchy.wiki}~\cite{cryptoanarchy}:

\begin{verbatim}
  The Cypherpunks mailing list was started in 1992, and by 1994
  had 700 subscribers. At its peak, it was a very active forum
  with technical discussion ranging over mathematics, cryptography,
  computer science, political and philosophical discussion,
  personal arguments and attacks, etc., with some spam thrown in.
  An email from John Gilmore reports an average of 30 messages
  a day from December 1, 1996 to March 1, 1999, and suggests that
  the number was probably higher earlier. The number of subscribers
  is estimated to have reached 2000 in the year 1997.
\end{verbatim}

It is during this period that the community was energised by a battle with the US intelligence establishment relating to the export of cryptography (which the US Government had at the time classified as a munition). This is a battle that the cypherpunk movement and broader civilian cryptography community largely won, though some variations of government proposals still pop up to this day. More about the cypherpunks mailing list and the archived conversations can be found in cryptoanarchy wiki~\cite{cryptoanarchy}.

Building upon the notion that money is any object, or any sort of record, accepted as payment for goods and services and repayment of debts in a given country or socio-economic context, Bitcoin is designed around the idea of using cryptography to control the creation and transfer of money rather than relying on central authorities.

Bitcoin is pseudonymous~\cite{gtklocker}: the identity of each user is only their \emph{address}, which corresponds to an ECDSA public key~\cite{ecdsa}. This address can be used to receive money from other users. Each user can spend money only if they have their corresponding private key. A set of ECDSA keypairs comprises a \emph{wallet}. A user can have multiple addresses.

As in fiat money, transfer of value in Bitcoin happens with transactions. A \hyperref[sec:transactions]{transaction} has \hyperref[sec:inputs]{inputs} and \hyperref[sec:outputs]{outputs}. An output is where the value creation happens for the receiver. An output can be later redeemed by using its designated receiver's private key and turned into an input to be used for another transaction.

Bitcoins have all the desirable properties of a money-like good. They are portable, durable, divisible, recognizable, fungible, scarce and difficult to counterfeit.

\subsection{Scripts}
Bitcoin offers much more than just moving currency around. It allows us to actually move currency conditionally, where the condition can be expressed as a \emph{Bitcoin script}. Bitcoin script is a stack-based language. An example of a Bitcoin script can be seen on \hyperref[fig:bitcoin-script]{figure}~\ref{fig:bitcoin-script}.

\begin{figure}[hb]
  \centering
  {
    \tt
    OP\_HASH256 \\
    6fe28c0ab6f1b372c1a6a246ae63f74f931e8365e15a089c68d6190000000000 \\
    OP\_EQUAL
  }
  \caption{A Bitcoin script~\cite{gtklocker}}
  \label{fig:bitcoin-script}
\end{figure}

This script introduces two kinds of formats. The first kind is commands prefixed with \code{OP\_}. These operations are called \emph{opcodes} and they perform calculations on values on the stack. The result is pushed again to the stack. The type of the calculations are intuitive, e.g. \code{OP\_HASH256} calculates the SHA256 hash of the value on the top of the stack, \code{OP\_EQUALS} compares the top 2 values on the stack and pushes 1 if they are indeed equal or 0 otherwise. The second kind is hex values. These values are simply pushed to the stack. Usually they will be used as input for some operation.

It is easy for the reader to see that the script of \hyperref[fig:bitcoin-script]{figure}~\ref{fig:bitcoin-script} checks if the value on the stack is the preimage of the given hash value and returns 1 (true) or 0 (false). In practice, this output confirms the success of the evaluation. Such a script is called a \textsf{pubKeyScript}. However, in our example we assume the preimage was on the stack. The way this is implemented in Bitcoin is running another script called \textsf{scriptSig} that passes the parameters to \textsf{pubKeyScript}. The combination of these two scripts is enough powerful and the calculations they perform can be used to make a transaction in the Bitcoin network.

Now, let's see the standard script for conventional fund transfer in Bitcoin, called \emph{pay to public key hash} (P2PKH).

% check https://en.bitcoinwiki.org/wiki/Pay-to-Pubkey_Hash for scheme and language for the following subsubsection.
%%%%% Begin from here tomorrow. After checking wiki, maybe you need to correct the paragraph above.

%%%%% v2. Now everything is kind of corrected. Please, refine the language. The whole section seems
% confusing to someone who hasn't heard about bitcoin scripts.

\subsubsection{P2PKH}
Two types of payment are referred as P2PK (pay to public key) and P2PKH (pay to public key hash).
Satoshi later decided to use P2PKH instead of P2PK for two reasons:

\begin{itemize}
  \item Elliptic Curve Cryptography is vulnerable to a modified Shor's algorithm for solving the discrete logarithm problem on elliptic curves. That means, that in the future a quantum computer might be able to retrieve a private key from a public key. By publishing the public key only when coins are spent (and assuming that addresses are not reused), such an attack is rendered ineffective.
  \item With the hash being smaller (20 bytes) it is easier to print and easier to embed into small storage mediums like QR codes.
\end{itemize}

A Bitcoin address is only a hash, so the sender can't provide a full public key in \textsf{pubKeyScript}. When redeeming coins that have been sent to a Bitcoin address, the recipient provides both the signature and the public key. The script verifies that the provided public key does hash to the hash in \textsf{pubKeyScript}, and then it also checks the signature against the public key. The reader can see the process in detail in \hyperref[tab:bitcoin]{table}~\ref{tab:bitcoin}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% This is for the final format, and maybe I put it here too early, but it seemed right.
%\pagebreak
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Don't freak out. The next lines were made with this tool: https://www.tablesgenerator.com/
%% If any debugging is needed, I strongly suggest the online tool.
%% Enjoy!
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{table}[ht]
  \centering
\begin{tabular}{@{}lll@{}}
\toprule
\rowcolor[HTML]{C0C0C0}
\multicolumn{1}{c}{\cellcolor[HTML]{C0C0C0}\textbf{Stack}}                                                                                                                                          & \multicolumn{1}{c}{\cellcolor[HTML]{C0C0C0}\textbf{Script}}                                                                                                                                                          & \multicolumn{1}{c}{\cellcolor[HTML]{C0C0C0}\textbf{Description}}                                                   \\ \midrule
\multicolumn{1}{|l|}{Empty}                                                                                                                                                                         & \multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}\textless{}sig\textgreater{}\textless{}pubKey\textgreater \\ OP\_DUP OP\_HASH160\\ \textless{}pubKeyHash\textgreater \\ OP\_EQUALVERIFY \\ OP\_CHECKSIG\end{tabular}} & \multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}scriptSig and\\ scriptPubKey\end{tabular}}                          \\ \midrule
\multicolumn{1}{|l|}{\begin{tabular}[c]{@{}l@{}}\textless{}pubKey\textgreater\\ \textless{}sig\textgreater{}\end{tabular}}                                                                          & \multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}OP\_DUP OP\_HASH160\\ \textless{}pubKeyHash\textgreater \\ OP\_EQUALVERIFY \\ OP\_CHECKSIG\end{tabular}}                                                              & \multicolumn{1}{l|}{\cellcolor[HTML]{FFFFFF}\begin{tabular}[c]{@{}l@{}}Constants\\ added\\ to stack.\end{tabular}} \\ \midrule
\multicolumn{1}{|l|}{\begin{tabular}[c]{@{}l@{}}\textless{}pubKey\textgreater\\ \textless{}pubKey\textgreater\\ \textless{}sig\textgreater{}\end{tabular}}                                          & \multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}OP\_HASH160\\ \textless{}pubKeyHash\textgreater \\ OP\_EQUALVERIFY \\ OP\_CHECKSIG\end{tabular}}                                                                      & \multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Top stack\\ item\\ duplicated.\end{tabular}}                        \\ \midrule
\multicolumn{1}{|l|}{\begin{tabular}[c]{@{}l@{}}\textless{}pubKeyHashA\textgreater\\ \textless{}pubKey\textgreater\\ \textless{}sig\textgreater{}\end{tabular}}                                     & \multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}\textless{}pubKeyHash\textgreater \\ OP\_EQUALVERIFY \\ OP\_CHECKSIG\end{tabular}}                                                                                    & \multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Top stack\\ item\\ hashed.\end{tabular}}                            \\ \midrule
\multicolumn{1}{|l|}{\begin{tabular}[c]{@{}l@{}}\textless{}pubKeyHash\textgreater\\ \textless{}pubKeyHashA\textgreater\\ \textless{}pubKey\textgreater\\ \textless{}sig\textgreater{}\end{tabular}} & \multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}OP\_EQUALVERIFY \\ OP\_CHECKSIG\end{tabular}}                                                                                                                         & \multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Constant\\ added.\end{tabular}}                                     \\ \midrule
\multicolumn{1}{|l|}{\begin{tabular}[c]{@{}l@{}}\textless{}pubKey\textgreater\\ \textless{}sig\textgreater{}\end{tabular}}                                                                          & \multicolumn{1}{l|}{OP\_CHECKSIG}                                                                                                                                                                                    & \multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Equality check\\ between the\\ top two stack\\ items.\end{tabular}} \\ \midrule
True                                                                                                                                                                                                & Empty.                                                                                                                                                                                                               & \begin{tabular}[c]{@{}l@{}}Signature is\\ checked for top\\ two stack items.\end{tabular}                          \\ \bottomrule
\end{tabular}
\bigskip
\caption{Bitcoin script process (successful)~\cite{p2pkh}}
\label{tab:bitcoin}
\end{table}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Table finished. Let's get back to normal mode... :P!!!
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This is the standard script for conventional fund transfer in Bitcoin. Let's say we want to make sure only Bob can satisfy this script. The \textsf{pubKeyScript} is the following:
\begin{center}
  \code{OP\_DUP OP\_HASH160 <Bob's address> OP\_EQUALVERIFY\footnote{This operation is a lot like \code{OP\_EQUAL} but instead of pushing 1 or 0  to the stack, it fails the script if the arguments are not equal or does nothing otherwise.} OP\_CHECKSIG}
\end{center}
\noindent The \textsf{scriptSig} is then typically \code{<Bob's signature> <Bob's public key>}.

Bob's signature will be available. We will see that it can be found on the hash of the transaction containing the output. The script will then duplicate his public key, check that it matches the one on the \text{pubKeyScript} and if it does, it will check that he has provided a valid signature with that public key. If all these checks pass, the stack will end up with 1 on top and the execution will be valid.

\subsection{\label{sec:outputs}Outputs}
An \emph{output} is a tuple ({\sf value, pubKeyScript}). The \textsf{value} refers to an amount of Bitcoin in Satoshi (where $\sf 10^8 \, Satoshi = 1 \, \bitcoin$) and \textsf{pubKeyScript} is a script which needs to be run against some stack and return 1 in order for \textsf{value} to be transferable.

\subsection{\label{sec:inputs}Inputs}
An input is the way an output is redeemed. Specifically, it contains 3 things:
\begin{itemize}
  \item The hash of the transaction where the output of interest is contained.
  \item An index clarifying which output in the transaction this input is referring to.
  \item A signature (called \textsf{scriptSig}) used for the validation of the output script.
\end{itemize}

For the transaction to be valid, the script inside the specified output when run on a stack with the contents of \textsf{scriptSig} should return 1. As a convention, when we talk about the value of an input we mean the value of the output it redeems.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Maybe the next step is Bitcoin transactions. Revise the above and start building
%% the road to mining. A! And update the READΜΕ.md! Maybe if you are bored sometime
%% fix the first pages also... It should take less than 15'...
%% Goodbye today's self, see you tomorrow.. This boring !@#$#@!$ will end sometime...
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{\label{sec:transactions}Transactions}
A \emph{transaction} is a collection of inputs and outputs. It uses the sum of the inputs' values as credit to debit each output accordingly. As it makes sense, a transaction is only valid as long as all its outputs and inputs are valid. It should also be clear that the value of the outputs should not exceed the value of the inputs, otherwise we would be creating value out of thin air with new transactions. Specifically this is expressed as $\sum_{\sf i \in inputs} {\sf i.value} \ge \sum_{\sf o \in outputs} {\sf o.value}$. This is sometimes called the \emph{Law of Conservation}.

In cases where $\sum_{\sf i \in inputs} {\sf i.value} > \sum_{\sf o \in outputs} {\sf o.value}$ we call
\begin{equation}
  \sum_{\sf i \in inputs} {\sf i.value} - \sum_{\sf o \in outputs} {\sf o.value}
\end{equation}
the \emph{transaction fee}. This is paid to the miner who successfully mines a block containing the transaction. This is one of the two ways Bitcoin uses to incentivize miners. In \hyperref[fig:transaction-internally]{figure}~\ref{fig:transaction-internally} the reader can see the notion described above in practice.

\begin{figure}[ht]
  \centering
  \includegraphics[width=0.9\columnwidth,keepaspectratio]{Images/transaction-internally.png}
  \caption{Transactions with their inputs and outputs~\cite{mastering}}
  \label{fig:transaction-internally}
\end{figure}

\subsection{\label{sec:blocks}Blocks}
A block contains a list of transactions, the first of which is called the \emph{coinbase transaction} which is where value creation happens in Bitcoin. The miner crafts this transaction granting them some amount of Bitcoins and this transaction is going to be valid only if the block turns out valid. The amount of the \emph{coinbase transaction} is fixed by the Bitcoin protocol. However, this doesn't mean that anyone can generate Bitcoin out of thin air: we'll see shortly how it actually comes at a cost with \hyperref[proofOfWork]{Proof of Work (PoW)}.

\begin{figure}[bh]
  \centering
  \includegraphics[width=0.9\columnwidth,keepaspectratio]{Images/block-structure.pdf}
  \caption{The block structure~\cite{Nakamoto_bitcoin:a}}
  \label{fig:block-structure}
\end{figure}

A block header contains mainly the hash of the previous block, a \hyperref[sec:merkle-trees]{Merkle root hash} to commit to a set of transactions, and a nonce. Blocks are always referenced by the hash of their block header. Once a transaction has been included in a valid block it's called \emph{confirmed}.

\subsection{\label{sec:blockchain}Blockchain}
Now, the reader can visualize the famous term \emph{blockchain}. The blockchain is a chain of blocks. The blockchain is public and it holds the history of all valid transactions in a cryptocurrency's network. It holds the timeline of a cryptocurrency's life. It is easy to see that, by the definition of the blockchain, there can be no parallel chains. There is not such thing in economics as two valid transaction histories.

It's possible that there are contending chains of blocks. We then say, there is a \emph{fork} on the chain. On \hyperref[fig:blocks]{figure}~\ref{fig:blocks}, the chain has forked on blocks 3 and 6.

We call any valid blocks which are not part of our active chain \emph{orphans}. In our example blocks 4b, 7a and 8a are orphans. As expected, orphans blocks, although typically valid, cannot be part of the transaction history. So, transactions that are included in an orphan block (and have not been included in another block yet) return back in the pool (become \emph{unconfirmed}\footnote{Note: The reader may find this peculiar. However, we observe that as the blockchain grows, older blocks become "safer" (less probability to become orphans). That means that after a transaction becomes confirmed (included in a valid block), one should wait until this valid block is "safe enough".}) and are expected to be included in a block in the future.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.9\columnwidth,keepaspectratio]{Images/blocks.png}
  \caption{A blockchain (the orange blocks are orphans)~\cite{mastering}}
  \label{fig:blocks}
\end{figure}

\subsection{\label{proofOfWork}Proof of Work (PoW)}
The key to making Bitcoin decentralized is a technique called Proof of Work (PoW). Proof of Work was first invented in 1992 by Dwork et al.~\cite{dwork} as a measure of limiting email spam and denial of service attacks and later explored by Back~\cite{hashcash} as Hashcash.

We'll examine a simplified model of Hashcash in order to explore the idea. Suppose we want to send an email to someone. In order to prove we've done work, we include a header (like \code{X-Hashcash}), which includes the receiver's email address, and a nonce\footnote{Hashcash headers actually contain 7 different fields which have been omitted here for simplicity. The simplified version explained here is not making the same security guarantees as Hashcash.}. The nonce is picked so that the hash of the header $H(email || nonce)$ has its 20 most significant bits be all 0. The only feasible way to find this is by brute-forcing the nonce. Once the sender has found the nonce, it's included in the header and sent.

The receiver can then very easily check whether the header hashes to a valid value. If that's so, the email it contains belongs to the receiver and the header is not being reused. After this confirmation, the email can be considered not spam.

To reiterate, the idea is having a series of data to commit to and a hole for the nonce, which is brute-forced to satisfy a necessary predicate on the hash, specifically that its $n$ most significant bits are all zeroes. This is exactly how Bitcoin implements Proof of Work. Instead of the hole being on an email header the hole is on the block header. For a block to be valid, its header has to satisfy a predicate like the above.

Bitcoin introduces a couple of differences. $n$ varies according to the block generation rate. Specifically, to translate the previous predicate to Bitcoin terminology, the hash of each block header has to satisfy \begin{equation} \label{eq:PoW}
  H({\sf blockHeader}) \le T
\end{equation}
where $T$ is called the \emph{target}. As the target goes up, the probability of being below it goes up and generating a valid block is easier. Conversely, if the target goes down it's harder to generate a valid block. To express this, in Bitcoin, $\frac{1}{T}$ is called the \emph{difficulty}.

To account for the block generation rate, which Bitcoin tries to keep to 1 block per 10 minutes, every 2016 blocks the target (and subsequently the difficulty) is adjusted accordingly. The target is calculated inside the Bitcoin software and is only a function of the blocks previously seen (frequently called their \emph{view}). So, as long as the Bitcoin nodes agree on the view, they'll agree on the target and all will consider the same set of incoming blocks as valid.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% This is for the final format, and maybe I put it here too early, but it seemed right.
%pagebreak
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Simplified Payment Verification (SPV)}
The size of the blockchain has reached 197GB by the beggining of January 2019, which makes it a very time consuming or even infeasible process to synchronise a full node. Fortunately, a solution was proposed in the original white paper ~\cite{Nakamoto_bitcoin:a}, which allows the creation of so-called \emph{lite nodes}.

Lite nodes only know the headers of the entire blockchain, which are constant-size for each block (80 bytes). At the time of writing of this thesis, the size of all block headers was $\sim$45MB. The lite node then asks the network for transactions concerning it (e.g. transactions concerning a specific public key). Full nodes of the network find such transactions and return them to the requester. For each transaction, the block header of the block it is included in, is returned along with a \hyperref[sec:merkle-trees]{Merkle tree} proof of inclusion which the lite node can then verify.

This protocol is reliable, as long as an adversary does not control the network of a lite node.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Mining}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Think about it, seems ugly
\setlength{\intextsep}{0pt}
\begin{wrapfigure}{L}{0.4\textwidth}
\centering
\includegraphics[width=0.40\textwidth]{Images/Bitcoin/mining_start.jpg}
\end{wrapfigure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Bitcoin mining\footnote{It is misleading to think that there is an analogy between gold mining and bitcoin mining. The fact is that gold miners are rewarded for producing gold, while bitcoin miners are not rewarded for producing bitcoins; they are rewarded for their record-keeping services.} is the processing of transactions in the digital currency system, in which the records of current Bitcoin transactions, \hyperref[sec:blocks]{\emph{blocks}}, are added to the record of past transactions, the \hyperref[sec:blockchain]{\emph{blockchain}}. Miners keep the blockchain consistent, complete, and unalterable by repeatedly grouping newly broadcast transactions into a block, which is then broadcast to the network and verified by recipient nodes~\cite{economist}. Each block contains a SHA-256 cryptographic hash of the previous block~\cite{economist}, thus linking it to the previous block and giving the blockchain its name.

To be accepted by the rest of the network, a new block must contain a \hyperref[proofOfWork]{Proof of Work (PoW)}. The PoW requires miners to find a number called a nonce, such that when the block content is hashed along with the nonce, the result is numerically smaller than the network's difficulty target~\cite{Nakamoto_bitcoin:a} and thus the \hyperref[eq:PoW]{PoW equation} is satisfied. This proof is easy for any node in the network to verify, but extremely time-consuming to generate, as for a secure cryptographic hash, miners must try many different nonce values before meeting the difficulty target.

The primary purpose of mining is to set the history of transactions in a way that is computationally impractical to modify by any one entity. By downloading and verifying the blockchain, bitcoin nodes are able to reach consensus about the ordering of events in bitcoin~\cite{wiki}.

As we noted in \hyperref[proofOfWork]{section}~\ref{proofOfWork}, every 2,016 blocks the difficulty target is adjusted based on the network's recent performance, with the aim of keeping the average time between new blocks at ten minutes. In this way, the system automatically adapts to the total amount of mining power on the network. Between 1 March 2014 and 1 March 2015, the average number of nonces miners had to try before creating a new block increased from 16.4 quintillion to 200.5 quintillion~\cite{difficulty_history}.

The Proof Of Work system, alongside the chaining of blocks, makes modifications of the blockchain extremely hard, as an attacker must modify all subsequent blocks in order for the modifications of one block to be accepted. As new blocks are mined all the time, the difficulty of modifying a block increases as time passes and the number of subsequent blocks (also called confirmations of the given block) increases~\cite{economist}.

Mining is also the mechanism used to introduce Bitcoins into the system: Miners are paid any transaction fees as well as a "subsidy" of newly created cryptocoins. This both serves the purpose of disseminating new cryptocoins in a decentralized manner as well as motivating people to provide security for the system~\cite{wiki}. To elaborate on the second part of this purpose, one can think about the structure of the consensus on the network. The network agrees by majority. So an attacker who controls 51\% of the mining power can successfully attack this structure. As more honest miners contribute to the network, the 51\% attack becomes less feasible.

\begin{wrapfigure}{R}{0.4\textwidth}
  \centering
  \includegraphics[width=0.4\textwidth,keepaspectratio]{Images/Bitcoin/mining.jpeg}
  \caption{Mining options}
  \label{fig:mining}
\end{wrapfigure}
Originally, Bitcoin mining was conducted on the CPUs of individual computers, with more cores and greater speed resulting in more profitability. After that, the system became dominated by multi-graphics card systems, then field-programmable gate arrays (FPGAs) and finally application-specific integrated circuits (ASICs), in the attempt to find more hashes per hour with less electrical power usage (see \hyperref[fig:mining]{figure}~\ref{fig:mining}).

Due to this constant escalation, it has become hard for prospective new miners to start. This adjustable difficulty is an intentional mechanism created to prevent inflation. To get around that problem, individuals often work in \emph{mining pools}. Mining pools are groups of miners who join their collective computational power and share their profit according to the contribution of each party.

Bitcoin generally started with individuals and small organizations handling the mining. At that time, start-up could be enabled by a single high-end gaming system. However, nowadays larger mining organizations might spend tens of thousands on one high-performance, specialized application-specific integrated circuit.

That creates a problem. In a system, which since its creation, it is supposed to distribute power among users, there has been a great power concentration in the hands of big companies, like Bitfury or 21, that develop ASICs to mine bitcoin. Because of the extreme cost of ASICs and extreme hashrate, someone who uses a multi-graphics card system or a CPU is out of competition. As a result, independent miners have largely dried up.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Today, I worked till here. Tomorrow is my trial, so maybe no work. Friday:
%% try to include photos to the above section. Maybe mining farms, of photos
%% of ASICs or FPGAs... Make it more of a readable document! Ciao...
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%
\section{Egalitarian Mining}
Let's consider several contexts where an adversary has an upper hand over the defender by using special hardware in an attack. These include password processing, hard-drive protection, cryptocurrency mining, resourse sharing, code obfuscation, etc. Memory-hard computing is a generic paradigm, which can protect the defender against attacks in the aforementioned contexts. Every task is amalgamated with a certain procedure requiring intensive access to RAM both in terms of size and bandwidth, so that transferring the computation to GPU, FPGA, and even ASIC brings little or no cost reduction. Cryptographic schemes that run in this framework become \emph{egalitarian} in the sense that both users and attackers are equal in the price-performance ratio conditions. When the cryptographic scheme is a hash fuction used for cryptocurrency mining, then we refer to this notion as \emph{egalitarian mining}.

But let's step back a little and think about the need for such a notion. Do we actually need it? Is egalitarian mining a way to destroy competition? Is it unfair? Shouldn't a miner be rewarded for the extra money he invested?

Many questions like the above have been asked and usually the answer is not descriptive enough of what really memory-hardness introduces to the world. We will try here to demonstrate concretely what it means for a cryptocurrency to offer egalitarian mining.

\emph{Egalitarian mining does not destroy competition.} The miner who invests more in hardware, is rewarded more. Each individual miner is rewarded according to the computation power he offers to the community. The real difference is that it is really easy for people to start mining with a single high-end gaming system. Hobbyists, who want to support the community are welcome to mine. In bitcoin system, this option is not available. In order to support the community by mining, you have to invest a lot of money on ASICs to be competitive. That means, that in general, the mining to support the Bitcoin project or for fun, is dead.

This is hurtful for a system, which by design is supposed to bring decentralization in the financial market. Because, without hobbyists, we are actually left with big companies handling almost all of the mining. Companies will comply with regulations that the government of each country enforces and cannot be expected to react and inspire political movements. Since countries can and they have, historically, collaborated against threats, a union of countries who can enforce regulations to companies that control more than 51\% of the hashing power, can bring a cryptocurrency to its knees, if seen as a threat. That scenario, does not fit in most definitions of security.

One of the reasons that cryptocurrencies have a bootstrapping period is because they need a big support community to distribute mining in order to guarantee security. When the total hashing power is a few high-end gaming systems, aquaring 51\% of the hashing power is feasible. As the support expands, the security is satisfied for all practical purposes. But when mining is dominated by companies then a totally trustless system gaves birth to a trusted party. That's against the motivation for the inception of a cryptocurrency and it raises questions like "\emph{Why should I trust the mining companies and support this cryptocoin? Do I trust my bank more? After all, my bank is just another company...}"

We are focusing on mining, but one should think about the possibilities of a \hyperref[proofOfWork]{Proof of Work (PoW)} mechanism in order to understand the contribution of a memory-hard hash function. The PoW mechanism is actually a voting system. Users vote for the right order of the transactions, for enabling new features in the protocol and for the honest money supply distribution. Therefore, it is important that during the voting process all participants have equal voting rights.

To sum up, for security and decentralization reasons, it is healthy for some cryptocurrency's mining power to be distributed among users. Memory-hardness sustains the competition, but it makes it less harsh and keeps the door open for hobbyists to support the community. It is extremely difficult for the corporate mining to aquire tremendous power for two reasons, and that is essential in a trustless system that aims to remain trustless.

\noindent The reasons are:
\begin{enumerate}[label=(\greek*)]
  \item It is not that lucrative for companies. If someone makes a big investment, he will get big rewards, but not insanely huge rewards leaving every hobbyist out of the mining community.
  \item Even if a lot of companies decide to participate, it is extremely difficult for them to aquire a combined 51\% of the total hashing power.
\end{enumerate}

Memory-hardness defends a system against the aforementioned prospect and thus strengthens the notion of any PoW cryptocurrency's security. Furthermore, no matter how much someone trusts the corporations involved,
\\
\begin{tcolorbox}[colback=red!5!white,colframe=red!75!black,title=in the words of Edward Snowden:]
  Security is a binary state. A system cannot be secure against malicious attackers and insecure against other "noble" parties. It is either secure or insecure. And if the prospect of an attack exists, then security collapses.
\end{tcolorbox}
%
\section{\label{sec:Monero}Monero}
%\setlength{\intextsep}{0pt}
\begin{wrapfigure}{L}{0.2\textwidth}
\centering
\includegraphics[width=0.20\textwidth]{Images/Monero/monero.png}
\end{wrapfigure}
Monero (XMR) is a decentralised open-source cryptocurrency. The project's fundamental feature is privacy - it aims to be a digital medium of exchange with untraceable payments, unlinkable transactions and resistance to blockchain analysis. The parties behind a Monero transaction are not known; this results in considerable increase of privacy compared to Bitcoin and its forks~\cite{monerodef}.

\subsection{History}
First, the construction was outlined in an October 2013 white paper by the pseudonymous figure Nicolas van Saberhagen and called \hyperref[sec:CryptoNote]{CryptoNote}~\cite{citeulike:14139412}. Later, in 2014, Bitcointalk forum user known as \emph{thankful\_for\_today} forked the codebase of Bytecoin (CryptoNote's reference implementation) into the name \textbf{BitMonero}, which is a compound of bit and Monero (literally meaning "coin" in Esperanto~\cite{esperanto}).

The release of BitMonero was very poorly received by the community that initially backed it. Plans to fix and improve Bytecoin with changes to block time, tail emission and block reward had all been ignored, and \emph{thankful\_for\_today} simply disappeared from the development scene. A group of users led by Johnny Mnemonic decided that the community should take over the project and five days later they did, while also changing the name to \emph{Monero}.

Due to its privacy features, Monero experienced rapid growth in market capitalization and transaction volume during the year 2016, faster and bigger than any other cryptocurrency that year. This growth was driven by its uptake in the darknet market. From the beginning, Monero has been used by people holding other cryptocurrencies like \hyperref[sec:Bitcoin]{Bitcoin} to break the link between transactions, with the other cryptocoins first converted to Monero, then after some delay converted back and sent to an address unrelated to those used before.

On January 10, 2017, the privacy of Monero transactions was further strengthened by the adoption of Bitcoin Core developer Gregory Maxwell's algorithm \emph{Confidential Transactions}, hiding the amounts being transacted, in combination with an improved version of \emph{Ring Signatures}.

In late 2017, malware and antivirus service providers blocked a JavaScript implementation of Monero miner \emph{Coinhive} that was embedded in websites and apps. Coinhive generated the script as an alternative to advertisements; a website or app could embed it and use website visitor's CPU to mine the cryptocurrency while the visitor is consuming the content of the webpage. However, some websites and apps did this without informing visitors and some hackers implemented it in a way that drained visitors' CPUs. As a result, the script was blocked by companies that offer ad blocking subscription lists, antivirus services and antimalware services.

Monero is actively encouraged to those seeking financial privacy, since payments and account balances remain entirely hidden, which is not the standard for most cryptocurrencies.

\subsection{Specifications}
Monero is~\cite{monero}:
\begin{description}
  \item [Untraceable] Monero uses a digital signature scheme called "ring signatures", which shuffles users' public keys in order to eliminate the possibility to identify a particular user.
  \item [Unlinkable] Monero employs a specific protocol which generates multiple unique one-time addresses that can only be linked by the payment receiver and are unfeasable to be revealed through blockhain analysis.
  \item [Secure] Monero is cryptographically secured. Moreover, the design of the algorithm used, consists in tremendous computational and electric capibilities that an adversary would need to even try to steal funds.
  \item [Private] Privacy is basically provided by the idea of anonymous transactions without any obligations to cooperate with third parties.
  \item [Analysis Resistant] Monero's blockchain analysis resistance results from unlinkability, which is achieved by using a modified version of the Diffie-Hellman exchange protocol that generates multiple one-time public addresses that can only be simply gathered by the message receiver, but hardly analyzed by confused foreigners inside the block explorer.
\end{description}

\subsubsection{Account}
In Monero, a wallet is called an account and it is a private account owned and operated by a Monero user. An account contains all of the Monero transactions a user has sent and received. Some user's account balance is a sum of all the Monero received, less the Monero sent.

A Monero account has two balances, a locked and an unlocked balance. The unlocked balance contains funds that can be spent immediately, and the locked balance contains funds that can't be spent right away. A Monero user may receive a transaction that has an unlock time set, or he/she may have sent some Monero and are waiting for the change to come back to his/her wallet, both situations that could lead to those funds being locked for a time.

An account resides only under user's control, normally on his/her computer, and cannot be accessed by anyone else if he/she practices good security~\cite{getmonero}.

\subsubsection{Keys}
A Monero account is based on two keys. They are called \emph{spend key} and \emph{view key}. The \emph{spend key} is special in that it is the single key required to spend your Monero funds, whereas the \emph{view key} allows you to reveal your transactions to a third party. That makes sense in case of auditing or accounting purposes.\\

The spine of the Monero project is the \hyperref[sec:CryptoNote]{CryptoNote} protocol. All the above specifications are based in ideas that exist in the CryptoNote white paper~\cite{citeulike:14139412}. Monero is the most successful implementation of this protocol, among numerous efforts. Describing every implementation is impractical and beyond the scope of this thesis.

However, it would be an inexcusable omission not to describe the features and specifications of the CryptoNote protocol itself. For our purposes, we will illustrate the above with Monero project in mind and especially one specific element, the CryptoNight function, which is the feature of interest in this thesis.

Unlike many cryptocurrencies that are derivatives of Bitcoin, Monero uses a proof of work mechanism to issue new coins and incentivize miners to secure the network and validate transactions. One key part, for Monero project to offer the above, is a proof-of-work algorithm called CryptoNight, developed by the \hyperref[sec:CryptoNote]{CryptoNote} project~\cite{citeulike:14139412}. On top of typical security attributes, this algorithm is also suspected to be memory-hard. The aim of this work is to study the memory-hardness property of this algorithm.
%
\section{\label{sec:CryptoNote}CryptoNote}
The CryptoNote Technology is designed to provide some of the most innovative privacy features predicated on advanced cryptography, an egalitarian approach towards decentralization, and censorship-resistance. CryptoNote, as described in the bitcoin forum~\cite{btcforum}, is the technology that allows creation of privacy-centric cryptocurrencies. The level of anonymity provided by CryptoNote isn't possible with Bitcoin code base by design. Bytecoin (BCN) was the CryptoNote reference implementation, and Monero (XMR) is based on BCN's code.

The CryptoNote protocol possesses significant algorithmic differences relating to blockchain obfuscation. One of the main features of CryptoNote, are ring signatures that mask sender identities by mixing and one-time keys that make transactions unlinkable. Their combined effect gives a high degree of anonymity without any extra effort on the part of the user.

Unlike Bitcoin, a user's funds are not held in the address he/she gives out to others. Instead, every time he/she receives a payment it goes to an unlinkable address generated with random numbers. When he/she decides to spend the funds in that one-time address, the amount will be broken down and the components will be indistinguishable from identical outputs in the blockchain.

For example if $556.44$ XMR are sent, the protocol will break it down into $500 + 50 + 6 + 0.4 + 0.04$ and a ring signature will be performed with other $500$'s, $50$'s, $6$'s, $0.4$'s, and $0.04$'s in the blockchain. Unlike the "CoinJoin" mixing method~\cite{coinjoin}, CryptoNote mixes outputs not transactions. This means no other senders need to be participating with some user at the same time or with the same amounts. Any arbitrary amount sent at any time can always be rendered fundamentally indistinguishable (a mathematical proof is given in the white paper)~\cite{citeulike:14139412}.

The degree of anonymity is also a choice rather than decided by the protocol: do you want to be hidden as one among five or one among fifty? The size of the signature grows linearly as $O(n+1)$ with the ambiguity, so greater anonymity is paid for, with higher fees to miners.

\subsection{Untraceable Transactions}
CryptoNote cryptographic scheme relies on the cryptographic primitive called a \emph{group signature}. First presented by D. Chaum and E. van Heyst~\cite{group}, it allows a user to sign his message on behalf of the group. The idea is actually simple. After signing the message the sender provides the keys of all the users of his group. A verifier is conviced that the real signer is a member of the group but cannot be exclusively identified.

However, this primitive required a trusted third party (Group Manager) who could trace the signer. The \emph{ring signature} was introduced by Rivest et al.~\cite{ring} and it was an autonomous scheme without anonymity revocation. Based on this work various modifications arose like \emph{linkable ring signature}~\cite{link1,link2,short}, a scheme that allowed to determine if two signatures were produced by the same group member, \emph{traceable ring signature}~\cite{traceable1,traceable2}, a scheme that limited anonymity (it is possible to trace the signer of two messages) and \emph{ad-hoc group signature}~\cite{ad-hoc1,ad-hoc2}. The last scheme focuses on the arbitrary group formation. The other schemes rather imply a fixed set of members.

Based on~\cite{traceable2} with a few modifications, in CryptoNote white paper~\cite{citeulike:14139412} is presented the \emph{one-time ring signature}. They weakened the traceability property and kept the linkability. That is needed because they wanted some user's public key to appear in many foreign verifying sets and from the private key to generate a unique anonymous signature. In case of a double spend attempt, these two signatures will be linked together. However, revealing the signer is not necessary.

In 2015, Shen Noether wrote a paper using a technique, introduced by Bitcoin Core developer Gregory Maxwell in~\cite{CT}, of using a commitment scheme to hide the amount of a transaction. The paper, introduced \emph{RingCT (Ring Confidential Transactions)}. This signature scheme is called \emph{A Multi-layered Linkable Spontaneous Anonymous Group signature} and that is how transaction amounts are hidden in Monero. Reproducing from~\cite{getmonero}:

\begin{verbatim}
  RingCT was implemented in block #1220516 in January 2017.
  After September 2017, this feature became mandatory for all
  transactions on the network.
\end{verbatim}
For further information the reader is refered to Shen Noether's paper~\cite{ringCT}.

The transaction structure remains similar to the structure in Bitcoin: every user can choose several independent incoming payments (transactions outputs), sign them with the corresponding private keys and send them to different destinations. Contrary to Bitcoin’s model, where a user possesses unique private and public key, in the proposed model a sender generates a one-time public key based on the recipient’s address and some random data. In this sense, an incoming transaction for the same recipient is sent to a one-time public key (not directly  to a unique  address) and only the recipient can recover the corresponding private part to redeem his funds (using his unique private key). The recipient can spend the funds using a ring signature, keeping his ownership and actual spending anonymous.

Ring signatures are explained below. We will start with a normal signature scheme shown in \hyperref[fig:normal_sig]{Fig.}~\ref{fig:normal_sig}. Reproduced from CryptoNote~\cite{cryptonote}:\\
\begin{figure}[ht]
  \centering
  \includegraphics[width=0.9 \columnwidth,keepaspectratio]{Images/CryptoNote/normal_sig.png}
  \caption{Normal signature: One participant, which allows one-to-one mapping.}
  \label{fig:normal_sig}
\end{figure}\\
In \hyperref[fig:ring_sig]{Fig.}~\ref{fig:ring_sig} we show the ring signature concept:\\
\begin{figure}[ht]
  \centering
  \includegraphics[width=0.9 \columnwidth,keepaspectratio]{Images/CryptoNote/ring_sig.png}
  \caption{Ring signature: Only proves that a signer belongs to a group.}
  \label{fig:ring_sig}
\end{figure}\\
The result is shown in \hyperref[fig:result]{Fig.}~\ref{fig:result}. The reader can think of it as decentralized and trustless mixing.
%% In the final document the following line needs to be uncommented in order to show the figures properly.
%\newpage
\begin{figure}[ht]
  \centering
  \includegraphics[width=0.9 \columnwidth,keepaspectratio]{Images/CryptoNote/result.png}
  \caption{High level of anonymity in cryptocurrency transactions.}
  \label{fig:result}
\end{figure}

%% Uncomment the following line in the final document, if it is placed after a figure. Looks bad otherwise.
%\noindent
Now that we have seen the whole concept, it is time to see what a transaction looks like in this context. Again reproduced from CryptoNote~\cite{cryptonote}, we will subjoin an example and a figure showing the details of a transaction from Bob to Carol.

Bob decides to spend an output, which was sent to the one-time public key. He needs Extra \textbf{(1)}, TxOutNumber \textbf{(2)}, and his Account private key \textbf{(3)} to recover his one-time private key \textbf{(4)}.

When sending a transaction to Carol, Bob generates its Extra value by random \textbf{(5)}. He uses Extra \textbf{(6)}, TxOutNumber \textbf{(7)} and Carol's Account public key \textbf{(8)} to get her Output public key \textbf{(9)}.

In the input Bob hides the link to his output among the foreign keys \textbf{(10)}. To prevent double-spending he also packs the Key image, derived from his One-time private key \textbf{(11)}.

Finally, Bob signs the transaction, using his One-time private key \textbf{(12)}, all the public keys \textbf{(13)} and Key Image \textbf{(14)}. He appends the resulting Ring Signature to the end of the transaction \textbf{(15)}.

The example above is illustrated in \hyperref[fig:transaction]{Fig.}~\ref{fig:transaction}.\\
\begin{figure}[ht]
  \centering
  \includegraphics[width=0.9 \columnwidth,keepaspectratio]{Images/CryptoNote/transaction.png}
  \caption{A sample transaction from Bob to Carol.}
  \label{fig:transaction}
\end{figure}
%
\subsection{Unlinkable transactions}
First, we should clarify the problem which is solved with unlinkability. Even if a transaction is untraceable, when the receiver posts his/her public address anyone can check all his/hers incoming transactions (see \hyperref[fig:linkable]{figure}~\ref{fig:linkable}). A naive solution is to create a bunch of keys and addresses that can be sent privately to the payers (one distinct key per payer). This approach is highly problematical since:
\begin{enumerate}[label=\alph*)]
  \item Deprives the receiver of the convenience of having a single public address
  \item Implies that the default use of the structure \textbf{DOES NOT} create unlinkable transactions
\end{enumerate}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.9 \columnwidth,keepaspectratio]{Images/CryptoNote/linkable.png}
  \caption{Linkable transactions.~\cite{cryptonote}}
  \label{fig:linkable}
\end{figure}

CryptoNote solves this problem. It creates automatically and by default multiple unique one-time keys, derived from the single public key, for each peer-to-peer payment. The solution lies in a clever modification of the Diffie-Hellman exchange protocol~\cite{Diffie:2006:NDC:2263321.2269104}. Originally, it allows two parties to produce a common secret key derived from their public keys. In CryptoNote protocol the sender uses the receiver's public address and his own random data to compute a one-time key for the payment.

The sender can produce only the public part of the key, whereas only the receiver can compute the private part; hence the receiver is the only one who can release the funds after the transaction is committed. He only needs to perform a single-formula check on each transactions to establish if it belongs to him. This process involves his private key, therefore no third party can perform this check and discover the link between the one-time key generated by the sender and the receiver's unique public address.

\begin{figure}[ht]
  \centering
  \includegraphics[width=0.9 \columnwidth,keepaspectratio]{Images/CryptoNote/unlinkable.png}
  \caption{Unlinkable transactions.~\cite{cryptonote}}
  \label{fig:unlinkable}
\end{figure}

An important part of CryptoNote is usage of random data by the sender. It always results in a different one-time key even if the sender and the receiver both remain the same for all transactions (that is why the key is called "one-time"). Moreover, even if they are both the same person, all the one-time keys will also be absolutely unique.

\subsubsection{Stealth addresses}
%\setlength{\intextsep}{0pt}
\begin{wrapfigure}[6]{L}{0.3\textwidth}
\centering
\includegraphics[width=0.30\textwidth]{Images/CryptoNote/stealth.jpg}
\end{wrapfigure}
The structure of the above concept is inherited in all CryptoNote projects. But the details of each implementation may differ. What we will present here is the implementation details of unlinkability, as found in the Monero project. The reader can find all the information of this section and more in CryptoNote paper~\cite{citeulike:14139412} and Monero project's code. An additional valuable source of information and interactive conversation that the reader is refered to is Monero stack exchange forum~\cite{stackexchange}. The implementation of CryptoNote's unlinkable transactions in Monero project is mentioned as \emph{stealth addresses}.

%% Monero stack exchange
Stealth address technology originated from Cryptonote technology, but Bitcoin (e.g. \emph{libbitcoin}) and its altcoins can also implement stealth addresses. For Bitcoin and its altcoins, stealth addresses must be explicitly supported by the sender's and recipient's wallets, but such support is implicit to Cryptonote wallets.

\begin{figure}
  \begin{verbatim}
    vJmsp9MxWMj6jiUg8Rejh23pqRCthWQhwtUKvmLw2kcE83AHer1MchTN4DVacHt
    43r8hSKBQpjPuqYDKuKgyVBkGkUdcsNAdnk2aZW
  \end{verbatim}
  \caption{Bitcoin stealth address.}
  \label{fig:btcstealth}
\end{figure}

For Bitcoin, stealth addresses are a bit longer than normal Bitcoin addresses (see \hyperref[fig:btcstealth]{figure}~\ref{fig:btcstealth}). However, the transactions associated with a stealth address looks no different than normal transactions on the Bitcoin Blockchain. Stealth addresses contain one public \textbf{view} (in CryptoNote vernacular) or \textbf{scan} (in Bitcoin vernacular) key, and one or more \textbf{spend} public keys. These keys are always encoded in a stealth address to support the first portion of Diffie-Helman-Merkle key exchange. Bitcoin's public/private key pairs are derived from the \emph{secp256k1} elliptic curve, while Cryptonote uses \emph{Ed25519} derived public/private key pairs.

One can publish their stealth address on a business card, and sustain their privacy when funds are sent to a dynamically computed destination address by the sender of funds. Stealth addresses essentially put the onus of dynamic address calculation, typically associated with a recipient's hierarchical deterministic (HD) wallet, on the sender's wallet. One stealth address is functionally akin to an HD wallet account, and can thus be used over and over for many fund transfers. Stealth addresses provide confidentiality for the recipient of transaction pairs that utilize information from a stealth address.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
So, simplifying a bit, in Bitcoin if there is one bitcoin associated to the public key $P$ and if Bob knows the corresponding private key $x$ such that $P = xG$\footnote{$G$ is the generator for the algebraic ring that is the base of the key construction. For our purpose, it suffices to think $G$ as a parameter of the user's existence in the Monero network, which is public and thus available to anyone}, then he can spend the Bitcoin by submitting a message (transaction) to the network signed with $x$.

There is one privacy issue, though: if Bob keeps using the same $P$ to receive Bitcoins, then any observer will be able to see all payments were made to the same entity that controls $P$ (Bob). This is the problem that stealth addresses solve.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Stealth addresses innately perform the first half of a Diffie-Helman-Merkle key exchange when a sender of funds receives a stealth address. With Bitcoin, two blockchain transactions are required to complete the sending of funds to a stealth address that will belong to the recipient of funds.

Since it is operationally improbable a sender's and recipient's wallets will communicate directly to each other, the first transaction is a persistent \verb|OP_RETURN| transaction that is used to complete the second half of a Diffie-Helman-Merkle key exchange. The second transaction is the actual sending of funds to a dynamically calculated destination address that is strongly based upon an ephemeral random number generator in the sender's wallet. The second half of the Diffie-Helman-Merkle key exchange, the \verb|OP_RETURN|, allows a recipient's wallet of a stealth transaction to dynamically calculate the private redemption key associated with a particular transaction to redeem the funds at a later date.

Stealth addresses can be extended to support multisig. This is a multisig capability that is more inherent to Bitcoin than Cryptonote.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
In the context of stealth addresses, addresses are now composed of two public keys, and the coins sent to Bob will not be sent to his stealth address on the blockchain, rather the stealth address will be used by the sender to produce fresh new bitcoin addresses for every new transaction. These new addresses, even though generated by the sender (Alice) and unknown to Bob until the transaction is made, will nonetheless be controlled by Bob! Here is how it works:

Bob creates two pairs of private and public keys. Let's denote them by $(a,A)$ and $(b,B)$, where by definition
\begin{align*}
  A = aG \mbox{ and } B = bG
\end{align*}
Bob makes the pair of public keys $(A,B)$ available to the network; this will be his stealth address.

Alice wishes to send one bitcoin to Bob. She wants to assign one bitcoin to a public key $P$ such that Bob knows $x$ and $P = xG$. She will construct such $P$ using Bob's stealth address by using a hashing function $\mathcal{H}$, choosing a random big number $r$, and setting
\begin{align*}
  P = \mathcal{H}(rA)G + B
\end{align*}
Then Alice sends the bitcoin to $P$, the transaction is broadcast along with $R = rG$ (but not $r$, which can't be recovered from $R$).

In order to get the money, Bob has to keep listening to the network for all new transactions and check whether one or more of these transactions are money that he should receive. When he sees Alice's transaction, he checks if $x := \mathcal{H}(aR)+b$ and realizes that:
\begin{align*}\label{eq:checkstealth}
  xG &= (\mathcal{H}(aR)+b)G \\
     &= \mathcal{H}(aR)G+bG \\
     &= \mathcal{H}(arG)G+B \\
     &= \mathcal{H}(raG)G+B \\
     &= \mathcal{H}(rA)G+B \\
     &= P
\end{align*}

Bob can reconstruct $x$ such that $P = xG$ and is therefore the owner of the bitcoin! Notice that neither Alice nor any observer has the ability to derive $x$ (because they don't know $a$ and $b$), and that besides Alice and Bob no one knows that $(x,P)$ was generated from Bob's stealth address (because they don't know $r$).
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% check whether you will write about Kovri or just cite the feature.

Ignoring middleman snooping on IP addresses associated with stealth address transaction pairs, only the two core parties involved in a transaction pair will know any identity details associated with sending funds to a stealth address. Hence, the need for Kovri I2P technology. Hence, stealth transactions by themselves don't provide 100\% anonymity protection. Also Confidential Transactions (CT) technology is needed by Bitcoin to mask details about the amount transferred by a transaction.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Note that, as mentioned, this protects Bob privacy, but it is still visible to the network that Alice, the entity that used to control that bitcoin, made a transaction. In order to obfuscate that action, Monero implements the use of Ring Signatures, which will allow Alice to, instead of directly signing the transaction, produce a proof that her, or several other people, did send a coin to Bob.

To sum up, in Monero, coins are received to a unique, one-time stealth address. The formula for stealth addresses, is as follows:

\begin{align*}
  P = \mathcal{H}(rA)G + B
\end{align*}

\noindent Where:
\begin{description}
  \item [G] The standard Ed25519 base point
  \item [A] Bob's public view key
  \item [B] Bob's public spend key
  \item [r] The new random scalar Alice chose for this transaction
  \item [$\mathcal{H}$] a hashing algorithm that returns a scalar (i.e., the hash output is interpreted as an integer and reduced modulo $l$)
  \item [P] The final stealth address (one-time output key, the destination where funds will actually be sent)
\end{description}
So, in a nutshell:
\begin{itemize}
  \item \emph{Stealth addresses} take care of \textbf{recipient's} privacy.
  \item \emph{Ring Signatures} take care of \textbf{sender's} privacy.
\end{itemize}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Construction example} %% needs a lot of fixing and citation.
Here is a functional example for deriving a Monero stealth address. Here we will examine the developer mechanics not cryptographic theory. Results below duplicate functionality that is part of \emph{Crypto Note Test Address}~\cite{teststealth}.

It is worth noting custom \verb|bytes_to_words|, \verb|sc_reduce32|, and \verb|secret_key_to_| \verb|public_key| executables (coded in C or C++) below were named after Monero's functions that yielded output results. C++ coding insights came from \verb|main.cpp|. The \verb|bx| command line is bitcoin-explorer, see~\cite{bx}.

Monero's \verb|secret_key_to_public_key()| functionality is using \emph{Ed25519} technology but not in a inclusive way. Only the necessary computations for the production of stealth addresses are implemented. Results are different from \emph{TOR} test vectors results that custom executables utilizing \emph{libsodium} and \emph{ed25519-donna} yield, but Monero C/C++ code results match that from \emph{Crypto Note Test Address}. Let us see the components and the calculations that take place in order to construct a stealth address.

The example that is presented here was posted by user \verb|skaht| on Monero stack exchange forum~\cite{stackexchange}. The calculations were checked and confirmed.
\begin{itemize}
  \item 256-bit hexadecimal-encoded seed is assumed to be:
  \begin{verbatim}
    198584347013dd91832be3d82529437db7cc8e1850e559cdd3872b29
    ca819601
  \end{verbatim}
  \item Electrum mnemonic words\footnote{These are the words that a wallet owner should remember in order to restore his wallet, if he forgets his password.} corresponding to seed (\verb|./bytes_to_words <above seed>|):
  \begin{verbatim}
    $ ./bytes_to_words 198584347013dd91832be3d82529437db7cc8
    e1850e559cdd3872b29ca819601
  \end{verbatim}
  \begin{tcolorbox}[colback=green!5!white,colframe=green!65!black,title=Output:]
    wallets drinks insult popular fall textbook scoop apology unsafe fifteen cuffs pimple roster nerves pixels upstairs academy sprig eclipse leopard peeled faxed gutter happens roster
  \end{tcolorbox}
  \item Private spend key calculation (\verb|./sc_reduce32 <private spend key>|):
  \begin{verbatim}
    $ ./sc_reduce32 198584347013dd91832be3d82529437db7cc8e185
    0e559cdd3872b29ca819601
  \end{verbatim}
  \begin{tcolorbox}[colback=green!5!white,colframe=green!65!black,title=Output:]
    \small{198584347013dd91832be3d82529437db7cc8e1850e559cdd3872b29ca819601}
  \end{tcolorbox}
  \item Private view key calculation (\verb|./keccak|\footnote{Hash function.}\verb=<private spend key> | ./sc_reduce=):
  \begin{verbatim}
    $ ./keccak 198584347013dd91832be3d82529437db7cc8e1850e559c
    dd3872b29ca819601
    $ ./sc_reduce32 <the keccak output>
  \end{verbatim}
  \begin{tcolorbox}[colback=green!5!white,colframe=green!65!black,title=Output:]
    \footnotesize{889DA12A88D36BCE0966AB1A79125779DD1F2FC6F1145DE131FD52A5B468796D}
    \tcblower
    \small{faa5defce980fdbd03b9dd4841371dfcdc1f2fc6f1145de131fd52a5b468790d}
  \end{tcolorbox}
  \item Public spend key calculation (\verb|./secret_key_to_public_key <private spend key>|):
  \begin{verbatim}
    $ ./secret_key_to_public_key 198584347013dd91832be3d82529437
    db7cc8e1850e559cdd3872b29ca819601
  \end{verbatim}
  \begin{tcolorbox}[colback=green!5!white,colframe=green!65!black,title=Output:]
    \small{b66991d7d7c68513533d0560f820d75adfb0911487ba62274b759f7b3ccd4a90}
  \end{tcolorbox}
  \item Public view key calculation (\verb|./secret_key_to_public_key <private view key>|):
  \begin{verbatim}
    $ ./secret_key_to_public_key faa5defce980fdbd03b9dd4841371
    dfcdc1f2fc6f1145de131fd52a5b468790d
  \end{verbatim}
  \begin{tcolorbox}[colback=green!5!white,colframe=green!65!black,title=Output:]
    \small{3c450f27cd6849d9130addb2c566d910c5ef9bf4cecaed547004496fda52a4ff}
  \end{tcolorbox}
\end{itemize}

Now, we should note that the calculation of the stealth address (hexadecimal format) is:
\begin{verbatim}
  prefix + public_spend_key + view_public_key + keccak_checksum_postfix
\end{verbatim}
The \verb|prefix| in Monero addresses is always $12$ and is a marking of a Monero address. In this context the character \verb|+| is used to mark concatenation of strings. The \verb|keccak_checksum_postfix| computation is:
\begin{itemize}
  \item Stealth address checksum calculation (\verb|./keccak <almost an address>|):
  \begin{verbatim}
    $ ./keccak 12 +
    b66991d7d7c68513533d0560f820d75adfb0911487ba62274b759f7b3ccd4a90 +
    3c450f27cd6849d9130addb2c566d910c5ef9bf4cecaed547004496fda52a4ff
  \end{verbatim}
  \begin{tcolorbox}[colback=green!5!white,colframe=green!65!black,title=Output:]
    \footnotesize{ADD568169DBF2C6D3F595EE8610A189955BECD1EDF150627CBF2F2C49B0AEA71}
  \end{tcolorbox}
  \item So, the hexadecimal format of a Monero stealth address is:
  \begin{verbatim}
    12b66991d7d7c68513533d0560f820d75adfb0911487ba62274b759f7b3ccd4
    a903c450f27cd6849d9130addb2c566d910c5ef9bf4cecaed547004496fda52
    a4ffADD56816
  \end{verbatim}
\end{itemize}

In order to convert a hexadecimal representation of a stealth address in base58 format we calculate the base58 format of each 8 bytes and concatenate the results (presented between brackets). For the conversion, we used \verb|bx| (bitcoin explorer~\cite{bx}):

\begin{enumerate}
  \item \verb|$ bx base58-encode 12b66991d7d7c685| ($\rightarrow$ \verb|48Y3H2eSZ6C|)
  \item \verb|$ bx base58-encode 13533d0560f820d7| ($\rightarrow$ \verb|4EUjY1B5viS|)
  \item \verb|$ bx base58-encode 5adfb0911487ba62| ($\rightarrow$ \verb|GCbCLPcmMiy|)
  \item \verb|$ bx base58-encode 274b759f7b3ccd4a| ($\rightarrow$ \verb|7aD69yqUsaH|)
  \item \verb|$ bx base58-encode 903c450f27cd6849| ($\rightarrow$ \verb|R8GLE3rvSwr|)
  \item \verb|$ bx base58-encode d9130addb2c566d9| ($\rightarrow$ \verb|dJtpZYG1peC|)
  \item \verb|$ bx base58-encode 10c5ef9bf4cecaed| ($\rightarrow$ \verb|3oipCqfUvCc|)
  \item \verb|$ bx base58-encode 547004496fda52a4| ($\rightarrow$ \verb|F89i86kuEjV|)
  \item \verb|$ bx base58-encode ffADD56816| ($\rightarrow$ \verb|Vr5GCdj|)
\end{enumerate}

Finally, we get the Monero stealth address:
\begin{tcolorbox}[colback=green!5!white,colframe=green!65!black]
  \small{48Y3H2eSZ6C4EUjY1B5viSGCbCLPcmMiy7aD69yqUsaHR8GLE3rvSwrdJtpZYG\\
  1peC3oipCqfUvCcF89i86kuEjVVr5GCdj}
\end{tcolorbox}

%%%% Cu tomorrow... Nice work today!

\subsection{Double-spending proof}
\subsection{Blockchain analysis resistance}
%%%% Maybe after here the complete transaction
\subsection{More about CryptoNote}
%%%% In here: Adaptive limits, smooth emission and ...? Maybe more, maybe nothing...

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Maybe some preparation for the next chapter? %%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
